# CSP-S 2020 初赛试题解析

## 一、单项选择题

### 1. C

$肉眼可见C比A大,而BD在二进制下分别是9位和10位,C是11位.$

### 2. B

$显然.$

### 3. B

$2048*1024*32*24*8*60/8/1024/1024/1024=90(GB).$

### 4. B

$\{\ \}\to\{a,b\}\to\{a\}\to\{a,c,d\}\to\{a,c\}.$

### 5. D

$A.4,5,1,5.$
$B.4,3,9,3.$
$C.2,7,10,7.$
$D.1,3,5,9.$

### 6. B

$B不是(不能放得下就放),C显然是,D也可能是(Dijkstra).$
$A.霍夫曼编码是字符出现的次数越多编码越短的编码方法,具体编码方法自行百度.$

### 7. A

$每个点,每条边都会跑一遍,时间复杂度为O(n+e).$

### 8. A

$把所有点分成两组,同一组里不能有边,边最多的情况应为和另一组的所有点都有一条边.$
$即求(24-x)x的最大值.(简单的数学题)$
$(24-x)x \le [(24-x)+x]^{2}/4 = 144.(当且仅当x=12时取等)$

### 9. C

$显然.$

### 10. C

$CRT(中国剩余定定理)解同余方程组.$

$\begin{cases}
x \equiv 2 \pmod{3} \\
x \equiv 3 \pmod{5} \\
x \equiv 4 \pmod{7} \\
\end{cases}$

$当然最好是选项代入法.$

### 11. C

$求10k(k-1)/2 \ge 1000的最小整数解.$

### 12. D

$不能不会.$

### 13. B

$ans= 4*\sum_{i=1}^{3} 3(4-i).$
$(i为第一个棋子所在行,4是列数)$

### 14. D

$每次都要找出一个到源点距离最小的点,并用它更新剩下的点,时间复杂度O(N^{2}).$

### 15.  C

$香农信息论.$
$数学题里应该做到过香农公式:C=W* \log_2(1+\frac{S}{N}).$

## 二、阅读程序

### 1.

$d_{i}+d_{j}-(d_{i}\& d_{j}) \Leftrightarrow d_{i}|d_{j}.$

#### 判断题

##### (1) ×

$可以等于1000.$

##### (2) ×

$n=1时,ans=-1.$

##### (3) √

$行14的if条件为d_{i}<d_{j},所以i,j的前后顺序有影响.$
$若据题意更改j的初值,则if条件应为:d_{i}\ne d_{j}.$

##### (4) √

$ans的表达式中i,j的地位等同,即使当前d_{i}>d_{j},在某个循环时i和j的值会恰好调换.$

#### 单选题

##### (5) C

$由按位或的性质可知:a_{i} \le 127.$

##### (6) C

$输出奇数则至少有1个奇数,输出偶数则至少有2个偶数.$

### 2.

$find(L,R,k)是在d_{L,R}中找到第k小的数.$
$还加了奇怪的快排进去.$

$看不出为什么的问.$

#### 判断题

##### (1) ×

$x \in [L,R].$

##### (2) √

$程序运行到行19时,根据12的while循环条件,必有a=b.$

#### 选择题

##### (3) 均对

$单调递增,所以每层find()中都只会在a=b时交换一次.$
$交换次数与递归层数,即与随机化的x和k有关.$

##### (4) B

$在第一层递归中,d_{i}会基本变成一个单调递增的序列,交换次数是x的期望.$
$而在第一层递归中,E(x)=n/2.$

$再算上递归层数带来的必然次数,平均后大约为O(n).$

##### (5) A

$对每层递归减少的区间范围求期望,大约是\sum_{i=1}^{k}{{n}/{2^i}}.$
$平均情况下大约为O(n).$

$最坏情况下每层循环都只能使区间范围缩小1,时间复杂度为O(nk),即O(n^{2}).$

##### (6) D

$行12的while中等号在b上,所以若d_{i}均相等,则必然会成为最坏情况,时间复杂度为O(n^{2}).$

### 3.

~~笑死,完全看不懂.~~

$先读定义的两个class.$
$Map其实就是map<string,int>.$
$Queue其实就是queue<string>.$

$行83的for循环条件写得很怪,但是不难看出这是一个bfs.$

$LtoR函数是循环左移1位,RtoL函数是循环右移1位.$

$check看起来是在判断没有重复入列,并记录bfs的步数.$
$并且输出当s[0]和s[1]中都有st时的步数之和.$

#### 判断题

##### (1) √

$行76,显然.$

##### (2) ×

$显然不行,除非两个字符串都是对称的.$

##### (3) ×

$因为是循环字符串,所以bfs的广度只与字符串的长度有关.$
$Map在查找时,最坏次数只取决于内在的cnt.$
$最坏情况是每次都增加2个string.$
$次数为2[m(m+1)+m^{2}+(n-m)(n-m+1)+(n-m)^{2}].$
$(认为字符串比较是O(1))$
$用线性规划(你甚至可以肉眼观察)可以明白上述表达式最多是8n^{2}.$
$所以最坏的时间复杂度是O(n^{2})$
$(或者在次数上多一些,但绝不可能到O(n!))$

#### 选择题

##### (4) D

$手模一下,就会发现,在循环移动的条件下,互为倒序的两个字符串没有相同的时候.$
$所以check函数不会有输出.$

$只有在主函数的最后输出-1.$

##### (5) D

$len=\{4,6,8\} \to ans=\{4,14,28\} \to delta = \{10,14\}.$
$猜想这是一个二阶等差数列.$
$len=12时,ans=28+18+22=68,有这个选项,很好.$

~~别问,问就是不会.~~

##### (6) C

~~神马题目,完全不会.~~
$由(4),对于任意n\ge 3的倒序字符串,只要m=0(偶数),都不可能满足条件.$

## 三、完善程序

### 1.

$提示已经相当于让这题白给了.$

$从主函数开始.$

$行33的循环是在排序,显然,排序的标椎就是性价比.$

$故行35的if条件应为w_{j}/v_{j}<w_{j+1}/v_{j+1}.$
$但是注意到D选项,它和A在数学上等价.$
$而A选项事实上是整数除法,会自动取整,显然不符合要求.$
$并且即使它是实数除法,考虑到精度问题,我们会优先选择移项之后用乘法.$
$故行35为:w[j]*v[j+1]<w[j+1]*v[j].$

$行40的if是在预先处理第一块蛋糕,但它显然可以和下面的循环合并.$
$行42的else是蛋糕放不下的情况,所以行40的if是放的下的情况.$
$故行40为:v[1]<=B.$

$行41是把蛋糕放进去,故为:curV=v[1];curW=w[1].$

$行52的意义同行43,但是多了一个通分的步骤.$
$答案的实际值为:curW+(B-curV)*w_{i}/v_{i}.$
$结合print函数的具体含义,故行52为:curW*v[i]+(B-curV)*w[i],v[i].$

$行55是所有蛋糕都放进去的情况,故为:curW,1.$

#### (1) D (2) B (3) D (4) D (5) B

### 2.

$如提示,本题是一道朴素的二进制状压DP.$

$从主函数开始.$
$行33的循环是最基本的初始化.$
$因为Max数组会存在调用未出现下标对应的值的情况,故初始化成负数.$
$其实可以类比成达到性背包,负数就是未到达.$

$行40,由提示,x是高8位,y是低8位.$
$故:x=a>>8.$

$行41是v的初始化,显然,v=0.$

$行43的循环,结合选项,易知,是在处理当前数字的高8位是x,上一个数字的低8位是z的情况.$
$因为高8位是确定的,所以要计算的是低8位的价值.$
$所以,v=max(v,Max[x][z]+w(y$^$z)).$
$(to$_$max函数看不懂问)$

$行45的循环是在处理当前数字的低8位是y,下一个数字的高8位是z的情况.$
$而事实上,从背包的角度来看,行42的循环是调用背包求最大值,行45的循环是更新背包维护最大值.$
$故,Max[z][y]=max(Max[z][y],v+w((x$^$z)<<B)).$

$w(x)=x+popcnt(x).$
$w的返回值是s,而s的初值就是x,所以行14的循环是在处理x在二进制下1的个数.$
$注意到s++没有诸如if(x\& 1==1)的限制条件,所以循环内每次取的都恰好是x的某一个1.$
$所以行16可以填我们比较熟悉的x-=x\& -x,即在树状数组中每次取x的最低位1的操作.$
$而D和上述表达式是等价的.$

#### (1) D (2) B (3) C (4) A (5) B

